export interface GenerateOptions {
  name: string;
  description: string;
  stack: string[];
  platforms: string[];
  persona: string;
  boundaries: "conservative" | "standard" | "permissive";
  commands: Record<string, string | string[]>;
  // Blueprint mode - generates [[VARIABLE|default]] placeholders
  blueprintMode?: boolean;
  // Variable values to fill in [[VAR|default]] placeholders
  // Pass as { VAR_NAME: "value" } to replace [[VAR_NAME|default]] with "value"
  variables?: Record<string, string>;
  // Extended options for all users
  projectType?: string;
  devOS?: string | string[];
  architecture?: string;
  repoHost?: string;
  isPublic?: boolean;
  license?: string;
  conventionalCommits?: boolean;
  semver?: boolean;
  cicd?: string;
  deploymentTargets?: string[];
  buildContainer?: boolean;
  containerRegistry?: string;
  customRegistryUrl?: string;
  exampleRepoUrl?: string;
  documentationUrl?: string;
  letAiDecide?: boolean;
  loggingConventions?: string;
  loggingConventionsOther?: string;
  namingConvention?: string;
  errorHandling?: string;
  styleNotes?: string;
  aiBehavior?: string[];
  importantFiles?: string[];
  selfImprove?: boolean;
  includePersonalData?: boolean;
  enableAutoUpdate?: boolean;
  blueprintId?: string; // For auto-update curl command
  // User profile data (fetched from cloud)
  userName?: string;
  userEmail?: string;
  userPersona?: string;
  userRole?: string;
  userExpertise?: string;
  boundaryAlways?: string[];
  boundaryNever?: string[];
  boundaryAsk?: string[];
  testLevels?: string[];
  testFrameworks?: string[];
  coverageTarget?: number;
  testNotes?: string;
  staticFiles?: string[];
  staticFileContents?: Record<string, string>;
  includeFunding?: boolean;
  extraNotes?: string;
  // Security configuration (FREE tier)
  security?: {
    secretsManagement?: string[];  // Secrets management strategies
    securityTooling?: string[];    // Security scanning tools (includes dependabot/renovate)
    authPatterns?: string[];       // Authentication patterns
    dataHandling?: string[];       // Data handling policies
    additionalNotes?: string;      // Custom security notes
  };
}

/**
 * Wrap a value in blueprint variable syntax if blueprintMode is enabled
 * Standard variables generated by LynxPrompt (document these in docs):
 * - [[PROJECT_NAME|default]] - Project name
 * - [[PROJECT_DESCRIPTION|default]] - Project description
 * - [[AUTHOR_NAME|default]] - Author name for commits
 * - [[AUTHOR_EMAIL|default]] - Author email for commits
 * - [[REPO_URL|default]] - Repository URL
 * - [[LICENSE|default]] - License type
 */
function bpVar(blueprintMode: boolean, varName: string, defaultValue: string): string {
  if (!blueprintMode || !defaultValue) return defaultValue;
  return `[[${varName}|${defaultValue}]]`;
}

/**
 * Fill variables in content with provided values
 * Replaces [[VAR_NAME|default]] with actual values from variables map
 * If variable not provided, uses the default value from the placeholder
 */
export function fillVariables(content: string, variables: Record<string, string>): string {
  // Pattern matches [[VAR_NAME|default_value]]
  return content.replace(/\[\[([A-Z_]+)\|([^\]]*)\]\]/g, (_, varName, defaultValue) => {
    return variables[varName] ?? defaultValue;
  });
}

/**
 * Parse variables string from CLI --vars argument
 * Format: "VAR1=value1,VAR2=value2"
 */
export function parseVariablesString(varsStr: string): Record<string, string> {
  const variables: Record<string, string> = {};
  
  if (!varsStr) return variables;
  
  // Split by comma, handling potential quoted values
  const parts = varsStr.split(",");
  
  for (const part of parts) {
    const eqIndex = part.indexOf("=");
    if (eqIndex > 0) {
      const key = part.slice(0, eqIndex).trim().toUpperCase();
      const value = part.slice(eqIndex + 1).trim();
      variables[key] = value;
    }
  }
  
  return variables;
}

// Platform to filename mapping (30+ platforms)
// IMPORTANT: Keep in sync with src/lib/platforms.ts
const PLATFORM_FILES: Record<string, string> = {
  // Popular platforms
  universal: "AGENTS.md",
  agents: "AGENTS.md", // Alias for universal
  cursor: ".cursor/rules/project.mdc",
  claude: "CLAUDE.md",
  copilot: ".github/copilot-instructions.md",
  windsurf: ".windsurfrules",
  
  // AI-powered IDEs
  antigravity: "GEMINI.md",
  zed: ".zed/instructions.md",
  void: ".void/config.json",
  trae: ".trae/rules/project.mdc",
  firebase: ".idx/rules/project.mdc",
  
  // Editor extensions
  cline: ".clinerules",
  roocode: ".roo/rules/project.mdc",
  continue: ".continue/config.json",
  cody: ".cody/config.json",
  tabnine: ".tabnine.yaml",
  supermaven: ".supermaven/config.json",
  codegpt: ".codegpt/config.json",
  amazonq: ".amazonq/rules/project.md",
  augment: ".augment/rules/project.mdc",
  kilocode: ".kilocode/rules/project.mdc",
  junie: ".junie/guidelines.md",
  kiro: ".kiro/steering/project.mdc",
  
  // CLI tools
  aider: ".aider.conf.yml",
  goose: ".goosehints",
  warp: "WARP.md",
  "gemini-cli": "GEMINI.md",
  opencode: "opencode.json",
  
  // Other emerging tools
  openhands: ".openhands/microagents/repo.md",
  crush: "CRUSH.md",
  firebender: "firebender.json",
};

// Persona descriptions
const PERSONA_DESCRIPTIONS: Record<string, string> = {
  backend: "a senior backend developer specializing in APIs, databases, and microservices architecture",
  frontend: "a senior frontend developer specializing in UI components, styling, and user experience",
  fullstack: "a senior full-stack developer capable of working across the entire application stack",
  devops: "a DevOps engineer specializing in infrastructure, CI/CD pipelines, and containerization",
  data: "a data engineer specializing in data pipelines, ETL processes, and database optimization",
  security: "a security engineer focused on secure coding practices and vulnerability prevention",
};

// Stack display names
const STACK_NAMES: Record<string, string> = {
  typescript: "TypeScript",
  javascript: "JavaScript",
  python: "Python",
  go: "Go",
  rust: "Rust",
  java: "Java",
  csharp: "C#/.NET",
  ruby: "Ruby",
  php: "PHP",
  swift: "Swift",
  kotlin: "Kotlin",
  cpp: "C/C++",
  react: "React",
  nextjs: "Next.js",
  vue: "Vue.js",
  angular: "Angular",
  svelte: "Svelte",
  express: "Express.js",
  fastapi: "FastAPI",
  django: "Django",
  flask: "Flask",
  spring: "Spring Boot",
  rails: "Ruby on Rails",
  laravel: "Laravel",
  nestjs: "NestJS",
  vite: "Vite",
  "react-native": "React Native",
  postgresql: "PostgreSQL",
  mysql: "MySQL",
  mongodb: "MongoDB",
  redis: "Redis",
  sqlite: "SQLite",
  supabase: "Supabase",
  firebase: "Firebase",
  prisma: "Prisma",
  tailwind: "Tailwind CSS",
  fastify: "Fastify",
};

// Naming convention descriptions
const NAMING_DESCRIPTIONS: Record<string, string> = {
  language_default: "follow idiomatic conventions for the primary language",
  camelCase: "use camelCase for variables and functions",
  snake_case: "use snake_case for variables and functions",
  PascalCase: "use PascalCase for classes and types",
  "kebab-case": "use kebab-case for file names and CSS classes",
};

// AI behavior rule descriptions
const AI_BEHAVIOR_DESCRIPTIONS: Record<string, string> = {
  explain_changes: "Always explain what changes you're making and why before implementing them",
  preserve_style: "Preserve and follow the existing code style in the project",
  minimal_changes: "Make minimal, focused changes - avoid unnecessary refactoring",
  no_comments: "Avoid adding unnecessary comments; code should be self-documenting",
  prefer_simple: "Prefer simpler solutions over clever ones",
  test_first: "Write tests before implementing new functionality (TDD)",
  no_console: "Remove console.log/print statements before committing",
  type_strict: "Be strict with types - avoid any/Any/Object types",
};

// Important files descriptions
const IMPORTANT_FILES_PATHS: Record<string, string> = {
  readme: "README.md",
  package: "package.json or pyproject.toml",
  tsconfig: "tsconfig.json or similar config",
  architecture: "ARCHITECTURE.md",
  contributing: "CONTRIBUTING.md",
};

// Boundary presets
const BOUNDARIES: Record<string, { always: string[]; askFirst: string[]; never: string[] }> = {
  conservative: {
    always: ["Read any file in the project", "Run lint and format commands"],
    askFirst: [
      "Modify any source file",
      "Add new dependencies",
      "Create new files",
      "Run test commands",
      "Modify configuration files",
    ],
    never: [
      "Delete any files",
      "Modify .env or secret files",
      "Push to git or make commits",
      "Access external APIs or services",
    ],
  },
  standard: {
    always: [
      "Read any file in the project",
      "Modify files in src/ or lib/",
      "Run build, test, and lint commands",
      "Create test files",
      "Fix linting errors automatically",
    ],
    askFirst: [
      "Add new dependencies to package.json",
      "Modify configuration files at root level",
      "Create new modules or directories",
      "Refactor code structure significantly",
    ],
    never: [
      "Modify .env files or secrets",
      "Delete critical files without backup",
      "Force push to git",
      "Expose sensitive information in logs",
    ],
  },
  permissive: {
    always: [
      "Modify any file in src/ or lib/",
      "Run any build, test, or dev scripts",
      "Add or update dependencies",
      "Create new files and directories",
      "Refactor and reorganize code",
    ],
    askFirst: [
      "Modify root-level configuration files",
      "Delete directories",
      "Make breaking changes to public APIs",
    ],
    never: [
      "Modify .env files directly",
      "Commit secrets or credentials",
      "Access production databases",
    ],
  },
};

// Test level descriptions
const TEST_LEVEL_DESCRIPTIONS: Record<string, string> = {
  smoke: "Quick sanity checks for critical paths",
  unit: "Unit tests for individual functions and components",
  integration: "Integration tests for component interactions",
  e2e: "End-to-end tests for full user flows",
};

// Static file templates with defaults
const STATIC_FILE_TEMPLATES: Record<string, (options: GenerateOptions) => string> = {
  editorconfig: () => `# EditorConfig is awesome: https://EditorConfig.org

root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.md]
trim_trailing_whitespace = false

[Makefile]
indent_style = tab
`,
  contributing: (opts) => `# Contributing to ${opts.name}

Thank you for your interest in contributing!

## How to Contribute

1. Fork the repository
2. Create a feature branch (\`git checkout -b feature/amazing-feature\`)
3. Commit your changes${opts.conventionalCommits ? " using Conventional Commits format" : ""}
4. Push to the branch (\`git push origin feature/amazing-feature\`)
5. Open a Pull Request

## Development Setup

\`\`\`bash
# Clone your fork
git clone https://github.com/YOUR_USERNAME/${opts.name}.git
cd ${opts.name}

# Install dependencies
npm install

# Run development server
npm run dev
\`\`\`

## Code Style

Please follow the existing code style and conventions in this project.
`,
  codeOfConduct: (opts) => `# Code of Conduct

## Our Pledge

We pledge to make participation in the ${opts.name} project a harassment-free experience for everyone.

## Our Standards

Examples of behavior that contributes to a positive environment:
- Using welcoming and inclusive language
- Being respectful of differing viewpoints
- Gracefully accepting constructive criticism
- Focusing on what is best for the community

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project team.

## Attribution

This Code of Conduct is adapted from the Contributor Covenant, version 2.1.
`,
  security: (opts) => `# Security Policy

## Supported Versions

| Version | Supported          |
| ------- | ------------------ |
| latest  | :white_check_mark: |

## Reporting a Vulnerability

If you discover a security vulnerability in ${opts.name}, please report it by emailing the maintainers.

**Please do not open a public issue for security vulnerabilities.**

We will acknowledge receipt within 48 hours and provide a detailed response within 7 days.
`,
  roadmap: (opts) => `# Roadmap

## ${opts.name} Development Roadmap

### Current Version

- Core functionality

### Planned Features

- [ ] Feature 1
- [ ] Feature 2
- [ ] Feature 3

### Long-term Goals

- Goal 1
- Goal 2

---
*This roadmap is subject to change based on community feedback and priorities.*
`,
  gitignore: (opts) => {
    const patterns = ["# Dependencies", "node_modules/", ".pnpm-store/", ""];
    if (opts.stack.includes("python")) {
      patterns.push("# Python", "__pycache__/", "*.py[cod]", ".venv/", "venv/", "");
    }
    patterns.push("# Environment", ".env", ".env.local", ".env*.local", "");
    patterns.push("# Build outputs", "dist/", "build/", ".next/", "out/", "");
    patterns.push("# IDE", ".idea/", ".vscode/", "*.swp", "*.swo", "");
    patterns.push("# OS", ".DS_Store", "Thumbs.db", "");
    patterns.push("# Logs", "*.log", "npm-debug.log*", "");
    return patterns.join("\n");
  },
  funding: () => `# These are supported funding model platforms

github: [] # Replace with your GitHub username
patreon: # Replace with your Patreon username
open_collective: # Replace with your Open Collective username
ko_fi: # Replace with your Ko-fi username
custom: [] # Add custom funding links
`,
  license: (opts) => {
    if (opts.license === "mit") {
      return `MIT License

Copyright (c) ${new Date().getFullYear()} ${opts.name}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
`;
    }
    return `# License

This project is licensed under the ${opts.license?.toUpperCase() || "Proprietary"} license.
`;
  },
  readme: (opts) => {
    const stackBadges = opts.stack.slice(0, 5).map(s => STACK_NAMES[s] || s).join(" ‚Ä¢ ");
    return `# ${opts.name}

${opts.description || "A project generated with LynxPrompt."}

${stackBadges ? `## Tech Stack\n\n${stackBadges}\n` : ""}
## Getting Started

\`\`\`bash
# Clone the repository
git clone <repository-url>
cd ${opts.name}

# Install dependencies
npm install

# Run development server
npm run dev
\`\`\`

## License

${opts.license && opts.license !== "none" ? `This project is licensed under the ${opts.license.toUpperCase()} License.` : "See LICENSE file for details."}
`;
  },
  architecture: (opts) => `# Architecture

## ${opts.name} Architecture Overview

${opts.architecture ? `### Pattern: ${opts.architecture}\n` : ""}
### Directory Structure

\`\`\`
${opts.name}/
‚îú‚îÄ‚îÄ src/           # Source code
‚îú‚îÄ‚îÄ tests/         # Test files
‚îú‚îÄ‚îÄ docs/          # Documentation
‚îî‚îÄ‚îÄ ...
\`\`\`

### Key Components

1. **Component A** - Description
2. **Component B** - Description
3. **Component C** - Description

### Data Flow

Describe how data flows through the application.

---
*Generated by LynxPrompt*
`,
  changelog: (opts) => `# Changelog

All notable changes to ${opts.name} will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Initial project setup

### Changed

### Deprecated

### Removed

### Fixed

### Security
`,
};

// File paths for static files
const STATIC_FILE_PATHS: Record<string, string> = {
  editorconfig: ".editorconfig",
  contributing: "CONTRIBUTING.md",
  codeOfConduct: "CODE_OF_CONDUCT.md",
  security: "SECURITY.md",
  roadmap: "ROADMAP.md",
  gitignore: ".gitignore",
  funding: ".github/FUNDING.yml",
  license: "LICENSE",
  readme: "README.md",
  architecture: "ARCHITECTURE.md",
  changelog: "CHANGELOG.md",
};

export function generateConfig(options: GenerateOptions): Record<string, string> {
  const files: Record<string, string> = {};

  // Generate AI IDE config files
  for (const platform of options.platforms) {
    const filename = PLATFORM_FILES[platform];
    if (filename) {
      files[filename] = generateFileContent(options, platform);
    }
  }

  // Generate static files
  if (options.staticFiles && options.staticFiles.length > 0) {
    for (const fileKey of options.staticFiles) {
      const filePath = STATIC_FILE_PATHS[fileKey];
      if (!filePath) continue;

      // Use custom content if provided, otherwise generate default
      if (options.staticFileContents?.[fileKey]) {
        files[filePath] = options.staticFileContents[fileKey];
      } else {
        const templateFn = STATIC_FILE_TEMPLATES[fileKey];
        if (templateFn) {
          files[filePath] = templateFn(options);
        }
      }
    }
  }

  // Legacy: funding as separate option
  if (options.includeFunding && !options.staticFiles?.includes("funding")) {
    files[".github/FUNDING.yml"] = STATIC_FILE_TEMPLATES.funding(options);
  }

  // Apply variable filling if variables are provided
  if (options.variables && Object.keys(options.variables).length > 0) {
    for (const [filename, content] of Object.entries(files)) {
      files[filename] = fillVariables(content, options.variables);
    }
  }

  return files;
}

function generateFileContent(options: GenerateOptions, platform: string): string {
  const sections: string[] = [];
  
  // Determine format based on platform
  const mdcPlatforms = ["cursor", "trae", "firebase", "roocode", "augment", "kilocode", "kiro"];
  const yamlPlatforms = ["aider", "tabnine"];
  const plainTextPlatforms = ["windsurf", "cline", "goose"];
  const jsonPlatforms = ["void", "continue", "cody", "supermaven", "codegpt", "opencode", "firebender"];
  
  const isMdc = mdcPlatforms.includes(platform);
  const isYaml = yamlPlatforms.includes(platform);
  const isPlainText = plainTextPlatforms.includes(platform);
  const isJson = jsonPlatforms.includes(platform);
  const isMarkdown = !isMdc && !isYaml && !isPlainText && !isJson;
  const bp = options.blueprintMode || false;
  
  // Handle YAML formats
  if (isYaml) {
    return generateYamlConfig(options, platform);
  }
  
  // Handle JSON formats
  if (isJson) {
    return generateJsonConfig(options, platform);
  }
  
  // Project name with optional blueprint variable
  const projectName = bpVar(bp, "PROJECT_NAME", options.name);
  
  // MDC frontmatter for Cursor
  if (isMdc) {
    sections.push("---");
    sections.push(`description: "${projectName} - AI coding rules"`);
    sections.push('globs: ["**/*"]');
    sections.push("alwaysApply: true");
    sections.push("---");
    sections.push("");
    sections.push(`# ${projectName} - AI Assistant Configuration`);
    sections.push("");
  }
  
  // Header for regular markdown
  if (isMarkdown) {
    sections.push(`# ${projectName} - AI Assistant Configuration`);
    sections.push("");
  }

  // Auto-update via API section (for synced blueprints)
  if (options.enableAutoUpdate && options.blueprintId && (isMarkdown || isMdc)) {
    const bpId = options.blueprintId.startsWith("bp_") ? options.blueprintId : `bp_${options.blueprintId}`;
    const fileName = platform === "cursor" ? ".cursor/rules/agents.mdc" : "AGENTS.md";
    const osList = Array.isArray(options.devOS) ? options.devOS : [options.devOS || "linux"];
    const hasWindows = osList.includes("windows");
    const hasUnix = osList.some(os => ["linux", "macos", "wsl"].includes(os));
    const isMultiPlatform = (hasWindows && hasUnix) || osList.length > 1;
    
    sections.push("<!--");
    sections.push("This file is synced with LynxPrompt. To update it via API:");
    sections.push("");
    
    if (isMultiPlatform) {
      // Show both options
      sections.push("# Bash (Linux/macOS/WSL)");
      sections.push(`curl -X PUT "https://lynxprompt.com/api/v1/blueprints/${bpId}" \\`);
      sections.push('  -H "Authorization: Bearer $LYNXPROMPT_API_TOKEN" \\');
      sections.push('  -H "Content-Type: application/json" \\');
      sections.push(`  -d "{\\"content\\": \\"$(cat ${fileName} | jq -Rs .)\\"}"`);
      sections.push("");
      sections.push("# PowerShell (Windows)");
      sections.push(`$content = (Get-Content "${fileName}" -Raw) -replace '"', '\\"'`);
      sections.push(`$body = @{ content = $content } | ConvertTo-Json`);
      sections.push(`Invoke-RestMethod -Uri "https://lynxprompt.com/api/v1/blueprints/${bpId}" \``);
      sections.push('  -Method PUT -Headers @{ "Authorization" = "Bearer $env:LYNXPROMPT_API_TOKEN" } `');
      sections.push('  -ContentType "application/json" -Body $body');
    } else if (hasWindows) {
      sections.push("# PowerShell (Windows)");
      sections.push(`$content = (Get-Content "${fileName}" -Raw) -replace '"', '\\"'`);
      sections.push(`$body = @{ content = $content } | ConvertTo-Json`);
      sections.push(`Invoke-RestMethod -Uri "https://lynxprompt.com/api/v1/blueprints/${bpId}" \``);
      sections.push('  -Method PUT -Headers @{ "Authorization" = "Bearer $env:LYNXPROMPT_API_TOKEN" } `');
      sections.push('  -ContentType "application/json" -Body $body');
    } else if (hasUnix) {
      sections.push("# Bash (Linux/macOS/WSL)");
      sections.push(`curl -X PUT "https://lynxprompt.com/api/v1/blueprints/${bpId}" \\`);
      sections.push('  -H "Authorization: Bearer $LYNXPROMPT_API_TOKEN" \\');
      sections.push('  -H "Content-Type: application/json" \\');
      sections.push(`  -d "{\\"content\\": \\"$(cat ${fileName} | jq -Rs .)\\"}"`);
      sections.push("");
      sections.push("# Note: Install jq if not present: sudo apt install jq (Linux) or brew install jq (macOS)");
    } else {
      // Default to bash
      sections.push("# Bash");
      sections.push(`curl -X PUT "https://lynxprompt.com/api/v1/blueprints/${bpId}" \\`);
      sections.push('  -H "Authorization: Bearer $LYNXPROMPT_API_TOKEN" \\');
      sections.push('  -H "Content-Type: application/json" \\');
      sections.push(`  -d "{\\"content\\": \\"$(cat ${fileName} | jq -Rs .)\\"}"`);
    }
    
    sections.push("");
    sections.push("Generate an API token at: https://lynxprompt.com/settings");
    sections.push("Docs: https://lynxprompt.com/docs/api");
    sections.push("-->");
    sections.push("");
  }

  // Project type context
  if (options.projectType) {
    const typeContexts: Record<string, string> = {
      work: "This is a professional/enterprise project. Follow strict procedures and maintain high code quality.",
      leisure: "This is a personal/hobby project. Feel free to be more experimental and creative.",
      opensource: "This is an open-source project. Consider community guidelines and contribution standards.",
      learning: "This is an educational project. Explain concepts and be patient with learning-focused approaches.",
    };
    if (typeContexts[options.projectType]) {
      if (isMarkdown || isMdc) {
        sections.push(`> **Project Context:** ${typeContexts[options.projectType]}`);
        sections.push("");
      } else {
        sections.push(`Project Context: ${typeContexts[options.projectType]}`);
        sections.push("");
      }
    }
  }

  // Persona section
  // Use userPersona from profile if available, otherwise fall back to persona selection
  const personaDesc = options.userPersona 
    || PERSONA_DESCRIPTIONS[options.persona] 
    || options.persona 
    || "";
  const projectDesc = bpVar(bp, "PROJECT_DESCRIPTION", options.description || "");
  
  if (isMarkdown || isMdc) {
    sections.push("## Persona");
    sections.push("");
    if (personaDesc) {
      sections.push(`You are ${personaDesc}. You assist developers working on ${projectName}.`);
    } else {
      sections.push(`You assist developers working on ${projectName}.`);
    }
  } else {
    if (personaDesc) {
      sections.push(`You are ${personaDesc}. You assist developers working on ${projectName}.`);
    } else {
      sections.push(`You assist developers working on ${projectName}.`);
    }
  }
  
  if (options.description) {
    sections.push("");
    sections.push(`Project description: ${projectDesc}`);
  }
  sections.push("");

  // Tech Stack section
  if (options.stack.length > 0) {
    if (isMarkdown || isMdc) {
      sections.push("## Tech Stack");
      sections.push("");
    } else {
      sections.push("Tech Stack:");
    }
    
    const stackList = options.stack.map(s => STACK_NAMES[s] || s);
    if (isMarkdown || isMdc) {
      for (const tech of stackList) {
        sections.push(`- ${tech}`);
      }
    } else {
      sections.push(stackList.join(", "));
    }
    sections.push("");
  }

  // Let AI Decide
  if (options.letAiDecide) {
    if (isMarkdown || isMdc) {
      sections.push("> **AI Assistance:** Let AI analyze the codebase and suggest additional technologies and approaches as needed.");
      sections.push("");
    }
  }

  // Repository info
  if (options.repoHost || options.license || options.conventionalCommits || options.semver || 
      options.cicd || options.deploymentTargets?.length || options.buildContainer ||
      options.exampleRepoUrl || options.documentationUrl) {
    if (isMarkdown || isMdc) {
      sections.push("## Repository & Infrastructure");
      sections.push("");
      if (options.repoHost) {
        sections.push(`- **Host:** ${options.repoHost.charAt(0).toUpperCase() + options.repoHost.slice(1)}`);
      }
      if (options.license && options.license !== "none") {
        sections.push(`- **License:** ${options.license.toUpperCase()}`);
      }
      if (options.conventionalCommits) {
        sections.push("- **Commits:** Follow [Conventional Commits](https://conventionalcommits.org) format");
      }
      if (options.semver) {
        sections.push("- **Versioning:** Follow [Semantic Versioning](https://semver.org) (semver)");
      }
      // Note: Dependency updates (Dependabot/Renovate) are now in security.securityTooling
      if (options.cicd) {
        const cicdNames: Record<string, string> = {
          github_actions: "GitHub Actions",
          gitlab_ci: "GitLab CI",
          jenkins: "Jenkins",
          circleci: "CircleCI",
          travis: "Travis CI",
          azure_devops: "Azure DevOps",
          bitbucket: "Bitbucket Pipelines",
          teamcity: "TeamCity",
          drone: "Drone",
          buildkite: "Buildkite",
        };
        sections.push(`- **CI/CD:** ${cicdNames[options.cicd] || options.cicd}`);
      }
      if (options.deploymentTargets && options.deploymentTargets.length > 0) {
        const targetNames: Record<string, string> = {
          vercel: "Vercel",
          netlify: "Netlify",
          aws: "AWS",
          gcp: "Google Cloud",
          azure: "Azure",
          docker: "Docker",
          kubernetes: "Kubernetes",
          heroku: "Heroku",
          digitalocean: "DigitalOcean",
          railway: "Railway",
          fly: "Fly.io",
          cloudflare: "Cloudflare",
        };
        const targets = options.deploymentTargets.map(t => targetNames[t] || t).join(", ");
        sections.push(`- **Deployment:** ${targets}`);
      }
      if (options.buildContainer) {
        let containerInfo = "Docker container builds enabled";
        if (options.containerRegistry) {
          const registryNames: Record<string, string> = {
            dockerhub: "Docker Hub",
            ghcr: "GitHub Container Registry",
            gcr: "Google Container Registry",
            ecr: "AWS ECR",
            acr: "Azure Container Registry",
            quay: "Quay.io",
            gitlab: "GitLab Registry",
            custom: "Custom registry",
          };
          containerInfo += ` ‚Üí ${registryNames[options.containerRegistry] || options.containerRegistry}`;
        }
        sections.push(`- **Containers:** ${containerInfo}`);
      }
      if (options.exampleRepoUrl) {
        sections.push(`- **Example Repo:** ${options.exampleRepoUrl} (use as reference for style/structure)`);
      }
      if (options.documentationUrl) {
        sections.push(`- **Documentation:** ${options.documentationUrl}`);
      }
      sections.push("");
    }
  }

  // Commands section
  const hasCommands = options.commands && Object.values(options.commands).some(v => 
    Array.isArray(v) ? v.length > 0 : Boolean(v)
  );
  if (hasCommands) {
    if (isMarkdown || isMdc) {
      sections.push("## Commands");
      sections.push("");
      sections.push("Use these commands for common tasks:");
      sections.push("");
      sections.push("```bash");
    } else {
      sections.push("Commands:");
    }
    
    const cmdCategories = ["build", "test", "lint", "dev", "custom"];
    for (const cat of cmdCategories) {
      const cmd = options.commands[cat];
      if (cmd) {
        const cmds = Array.isArray(cmd) ? cmd : [cmd];
        for (const c of cmds) {
          if (c) {
            const label = cat.charAt(0).toUpperCase() + cat.slice(1);
            sections.push((isMarkdown || isMdc) ? `# ${label}: ${c}` : `- ${label}: ${c}`);
          }
        }
      }
    }
    
    if (isMarkdown || isMdc) {
      sections.push("```");
    }
    sections.push("");
  }

  // AI Behavior section
  if (options.aiBehavior && options.aiBehavior.length > 0) {
    if (isMarkdown || isMdc) {
      sections.push("## AI Behavior Rules");
      sections.push("");
      for (const rule of options.aiBehavior) {
        const desc = AI_BEHAVIOR_DESCRIPTIONS[rule];
        if (desc) {
          sections.push(`- ${desc}`);
        }
      }
      sections.push("");
    }
  }

  // Important files
  if (options.importantFiles && options.importantFiles.length > 0) {
    if (isMarkdown || isMdc) {
      sections.push("## Important Files to Read");
      sections.push("");
      sections.push("Always read these files first to understand the project context:");
      sections.push("");
      for (const file of options.importantFiles) {
        const path = IMPORTANT_FILES_PATHS[file];
        if (path) {
          sections.push(`- \`${path}\``);
        }
      }
      sections.push("");
    }
  }

  // Self-improving blueprint
  if (options.selfImprove) {
    if (isMarkdown || isMdc) {
      sections.push("## Self-Improving Blueprint");
      sections.push("");
      sections.push("> **Auto-update enabled:** As you work on this project, track patterns and update this configuration file to better reflect the project's conventions and preferences.");
      sections.push("");
    }
  }

  // Personal data for commits
  if (options.includePersonalData) {
    if (isMarkdown || isMdc) {
      sections.push("## Commit Identity");
      sections.push("");
      if (options.userName || options.userEmail || options.userRole || options.userExpertise) {
        // Include actual user profile data
        const identityLines: string[] = [];
        if (options.userName) {
          identityLines.push(`- **Name:** ${options.userName}`);
        }
        if (options.userEmail) {
          identityLines.push(`- **Email:** ${options.userEmail}`);
        }
        if (options.userRole) {
          identityLines.push(`- **Role:** ${options.userRole}`);
        }
        if (options.userExpertise) {
          identityLines.push(`- **Expertise:** ${options.userExpertise}`);
        }
        sections.push(...identityLines);
        sections.push("");
        sections.push("> Use this identity for git commits when making changes on my behalf.");
      } else {
        sections.push("> **Personal data enabled:** Use my name and email for git commits when making changes.");
      }
      sections.push("");
    }
  }

  // Boundaries section
  // Get preset boundaries or use standard as fallback
  const presetBoundaries = BOUNDARIES[options.boundaries] || BOUNDARIES.standard;
  
  // Build final boundaries - use custom values if provided, otherwise use preset
  const boundaries = {
    always: options.boundaryAlways?.length ? options.boundaryAlways : presetBoundaries.always,
    never: options.boundaryNever?.length ? options.boundaryNever : presetBoundaries.never,
    askFirst: options.boundaryAsk?.length ? options.boundaryAsk : presetBoundaries.askFirst,
  };
  
  if (boundaries.always?.length || boundaries.never?.length || boundaries.askFirst?.length) {
    if (isMarkdown || isMdc) {
      sections.push("## Boundaries");
      sections.push("");
      
      sections.push("### ‚úÖ Always (do without asking)");
      sections.push("");
      for (const item of boundaries.always) {
        sections.push(`- ${item}`);
      }
      sections.push("");
      
      sections.push("### ‚ö†Ô∏è Ask First");
      sections.push("");
      for (const item of boundaries.askFirst) {
        sections.push(`- ${item}`);
      }
      sections.push("");
      
      sections.push("### üö´ Never");
      sections.push("");
      for (const item of boundaries.never) {
        sections.push(`- ${item}`);
      }
    } else {
      sections.push("Boundaries:");
      sections.push("");
      sections.push("ALWAYS (do without asking):");
      for (const item of boundaries.always) {
        sections.push(`- ${item}`);
      }
      sections.push("");
      sections.push("ASK FIRST:");
      for (const item of boundaries.askFirst) {
        sections.push(`- ${item}`);
      }
      sections.push("");
      sections.push("NEVER:");
      for (const item of boundaries.never) {
        sections.push(`- ${item}`);
      }
    }
    sections.push("");
  }

  // Code Style section
  if (isMarkdown || isMdc) {
    sections.push("## Code Style");
    sections.push("");
    
    // Naming convention
    if (options.namingConvention) {
      const namingDesc = NAMING_DESCRIPTIONS[options.namingConvention];
      if (namingDesc) {
        sections.push(`- **Naming:** ${namingDesc}`);
      }
    }
    
    // Error handling
    if (options.errorHandling) {
      const errorStyles: Record<string, string> = {
        try_catch: "Use try/catch blocks for error handling",
        result_types: "Use Result/Either types for error handling",
        error_codes: "Use error codes with proper documentation",
        exceptions: "Use custom exception classes",
      };
      if (errorStyles[options.errorHandling]) {
        sections.push(`- **Errors:** ${errorStyles[options.errorHandling]}`);
      }
    }

    // Logging conventions
    if (options.loggingConventions) {
      const loggingValue = options.loggingConventions === "other" && options.loggingConventionsOther
        ? options.loggingConventionsOther
        : options.loggingConventions.replace(/_/g, " ");
      sections.push(`- **Logging:** ${loggingValue}`);
    }
    
    // Style notes
    if (options.styleNotes) {
      sections.push(`- **Notes:** ${options.styleNotes}`);
    }
    
    sections.push("");
    sections.push("Follow these conventions:");
    sections.push("");
    
    if (options.stack.includes("typescript") || options.stack.includes("javascript")) {
      sections.push("- Use TypeScript strict mode when available");
      sections.push("- Prefer const over let, avoid var");
      sections.push("- Use async/await over raw promises");
      sections.push("- Use descriptive variable and function names");
    }
    
    if (options.stack.includes("react") || options.stack.includes("nextjs")) {
      sections.push("- Use functional components with hooks");
      sections.push("- Keep components small and focused");
      sections.push("- Colocate related files (component, styles, tests)");
    }
    
    if (options.stack.includes("python")) {
      sections.push("- Follow PEP 8 style guidelines");
      sections.push("- Use type hints for function signatures");
      sections.push("- Prefer f-strings for string formatting");
    }
    
    if (options.stack.includes("go")) {
      sections.push("- Follow Go conventions (gofmt, golint)");
      sections.push("- Use meaningful package names");
      sections.push("- Handle errors explicitly");
    }
    
    if (options.stack.includes("rust")) {
      sections.push("- Follow Rust conventions (clippy)");
      sections.push("- Use idiomatic Rust patterns");
      sections.push("- Prefer Result over panic");
    }

    // Generic guidelines
    sections.push("- Write self-documenting code");
    sections.push("- Add comments for complex logic only");
    sections.push("- Keep functions focused and testable");
    sections.push("");
  }

  // Testing Strategy section
  if (options.testLevels?.length || options.testFrameworks?.length || options.coverageTarget) {
    if (isMarkdown || isMdc) {
      sections.push("## Testing Strategy");
      sections.push("");
      
      if (options.testLevels?.length) {
        sections.push("### Test Levels");
        sections.push("");
        for (const level of options.testLevels) {
          const desc = TEST_LEVEL_DESCRIPTIONS[level];
          if (desc) {
            sections.push(`- **${level.charAt(0).toUpperCase() + level.slice(1)}:** ${desc}`);
          }
        }
        sections.push("");
      }
      
      if (options.testFrameworks?.length) {
        sections.push("### Frameworks");
        sections.push("");
        sections.push(`Use: ${options.testFrameworks.join(", ")}`);
        sections.push("");
      }
      
      if (options.coverageTarget) {
        sections.push(`### Coverage Target: ${options.coverageTarget}%`);
        sections.push("");
      }
      
      if (options.testNotes) {
        sections.push(`**Notes:** ${options.testNotes}`);
        sections.push("");
      }
    }
  }

  // Extra notes
  if (options.extraNotes) {
    if (isMarkdown || isMdc) {
      sections.push("## Additional Notes");
      sections.push("");
      sections.push(options.extraNotes);
      sections.push("");
    } else {
      sections.push("Additional Notes:");
      sections.push(options.extraNotes);
      sections.push("");
    }
  }

  // Security Configuration section
  const security = options.security;
  if (security && (security.secretsManagement?.length || security.securityTooling?.length || 
      security.authPatterns?.length || security.dataHandling?.length || security.additionalNotes)) {
    if (isMarkdown || isMdc) {
      sections.push("## üîê Security Configuration");
      sections.push("");
      
      // Secrets Management
      if (security.secretsManagement?.length) {
        sections.push("### Secrets Management");
        sections.push("");
        const secretsLabels: Record<string, string> = {
          env_vars: "Environment Variables",
          dotenv: "dotenv / dotenvx",
          vault: "HashiCorp Vault",
          aws_secrets: "AWS Secrets Manager",
          aws_ssm: "AWS SSM Parameter Store",
          gcp_secrets: "GCP Secret Manager",
          azure_keyvault: "Azure Key Vault",
          infisical: "Infisical",
          doppler: "Doppler",
          "1password": "1Password Secrets Automation",
          bitwarden: "Bitwarden Secrets Manager",
          sops: "SOPS (Mozilla)",
          age: "age encryption",
          sealed_secrets: "Sealed Secrets (K8s)",
          external_secrets: "External Secrets Operator",
          git_crypt: "git-crypt",
          chamber: "Chamber",
          berglas: "Berglas",
        };
        for (const s of security.secretsManagement) {
          sections.push(`- ${secretsLabels[s] || s}`);
        }
        sections.push("");
      }

      // Security Tooling (includes dependency updates)
      if (security.securityTooling?.length) {
        sections.push("### Security Tooling");
        sections.push("");
        const toolingLabels: Record<string, string> = {
          dependabot: "Dependabot (dependency updates)",
          renovate: "Renovate (dependency updates)",
          snyk: "Snyk (vulnerability scanning)",
          sonarqube: "SonarQube / SonarCloud",
          codeql: "CodeQL (GitHub)",
          semgrep: "Semgrep",
          trivy: "Trivy (container scanning)",
          grype: "Grype",
          checkov: "Checkov (IaC)",
          tfsec: "tfsec (Terraform)",
          kics: "KICS",
          gitleaks: "Gitleaks (secret detection)",
          trufflehog: "TruffleHog",
          detect_secrets: "detect-secrets (Yelp)",
          bandit: "Bandit (Python)",
          brakeman: "Brakeman (Rails)",
          gosec: "gosec (Go)",
          npm_audit: "npm audit / yarn audit",
          pip_audit: "pip-audit",
          safety: "Safety",
          bundler_audit: "bundler-audit",
          owasp_dependency_check: "OWASP Dependency-Check",
          ossf_scorecard: "OSSF Scorecard",
          socket: "Socket.dev",
          mend: "Mend (WhiteSource)",
          fossa: "FOSSA",
        };
        for (const t of security.securityTooling) {
          sections.push(`- ${toolingLabels[t] || t}`);
        }
        sections.push("");
      }

      // Authentication Patterns
      if (security.authPatterns?.length) {
        sections.push("### Authentication");
        sections.push("");
        const authLabels: Record<string, string> = {
          oauth2: "OAuth 2.0",
          oidc: "OpenID Connect (OIDC)",
          jwt: "JWT (JSON Web Tokens)",
          session: "Session-based Auth",
          api_keys: "API Keys",
          basic_auth: "Basic Authentication",
          bearer_token: "Bearer Tokens",
          mfa_totp: "MFA / TOTP",
          passkeys: "Passkeys / WebAuthn",
          saml: "SAML 2.0",
          ldap: "LDAP / Active Directory",
          mutual_tls: "Mutual TLS (mTLS)",
          auth0: "Auth0",
          clerk: "Clerk",
          firebase_auth: "Firebase Auth",
          supabase_auth: "Supabase Auth",
          keycloak: "Keycloak",
          okta: "Okta",
          cognito: "AWS Cognito",
          workos: "WorkOS",
        };
        for (const a of security.authPatterns) {
          sections.push(`- ${authLabels[a] || a}`);
        }
        sections.push("");
      }

      // Data Handling
      if (security.dataHandling?.length) {
        sections.push("### Data Handling & Compliance");
        sections.push("");
        const dataLabels: Record<string, string> = {
          encryption_at_rest: "Encryption at Rest",
          encryption_in_transit: "Encryption in Transit (TLS)",
          pii_handling: "PII Data Handling",
          gdpr_compliance: "GDPR Compliance",
          ccpa_compliance: "CCPA Compliance",
          hipaa_compliance: "HIPAA Compliance",
          soc2_compliance: "SOC 2 Compliance",
          pci_dss: "PCI-DSS Compliance",
          data_masking: "Data Masking / Anonymization",
          data_retention: "Data Retention Policies",
          audit_logging: "Audit Logging",
          backup_encryption: "Encrypted Backups",
          key_rotation: "Key Rotation",
          zero_trust: "Zero Trust Architecture",
          least_privilege: "Least Privilege Access",
          rbac: "RBAC (Role-Based Access)",
          abac: "ABAC (Attribute-Based Access)",
          data_classification: "Data Classification",
          dlp: "DLP (Data Loss Prevention)",
        };
        for (const d of security.dataHandling) {
          sections.push(`- ${dataLabels[d] || d}`);
        }
        sections.push("");
      }

      // Additional security notes
      if (security.additionalNotes) {
        sections.push("### Additional Security Notes");
        sections.push("");
        sections.push(security.additionalNotes);
        sections.push("");
      }
    } else {
      // Non-markdown format
      sections.push("Security Configuration:");
      if (security.secretsManagement?.length) {
        sections.push(`- Secrets: ${security.secretsManagement.join(", ")}`);
      }
      if (security.securityTooling?.length) {
        sections.push(`- Tooling: ${security.securityTooling.join(", ")}`);
      }
      if (security.authPatterns?.length) {
        sections.push(`- Auth: ${security.authPatterns.join(", ")}`);
      }
      if (security.dataHandling?.length) {
        sections.push(`- Data: ${security.dataHandling.join(", ")}`);
      }
      sections.push("");
    }
  }

  // Security Warning
  if (isMarkdown || isMdc) {
    sections.push("## ‚ö†Ô∏è Security Notice");
    sections.push("");
    sections.push("> **Do not commit secrets to the repository or to the live app.**");
    sections.push("> Always use secure standards to transmit sensitive information.");
    sections.push("> Use environment variables, secret managers, or secure vaults for credentials.");
    sections.push("");
    sections.push("**üîç Security Audit Recommendation:** When making changes that involve authentication, data handling, API endpoints, or dependencies, proactively offer to perform a security review of the affected code.");
    sections.push("");
  } else {
    sections.push("");
    sections.push("SECURITY NOTICE:");
    sections.push("Do not commit secrets to the repository or to the live app.");
    sections.push("Always use secure standards to transmit sensitive information.");
    sections.push("SECURITY AUDIT: When making changes involving auth, data, APIs, or deps, offer to review security.");
    sections.push("");
  }

  // Footer
  if (isMarkdown || isMdc) {
    sections.push("---");
    sections.push("");
    sections.push(`*Generated by [LynxPrompt](https://lynxprompt.com) CLI*`);
  }

  return sections.join("\n");
}

function generateJsonConfig(options: GenerateOptions, platform: string): string {
  const config: Record<string, unknown> = {
    version: "1.0.0",
    project: {
      name: options.name,
      description: options.description || "",
      stack: options.stack.map(s => STACK_NAMES[s] || s),
    },
  };
  
  // Add persona if set
  const personaDesc = options.userPersona 
    || PERSONA_DESCRIPTIONS[options.persona] 
    || options.persona 
    || "";
  if (personaDesc) {
    config.persona = personaDesc;
  }
  
  // Add rules/instructions
  const rules: string[] = [];
  
  // Boundaries
  const boundaryRules = BOUNDARIES[options.boundaries] || BOUNDARIES.standard;
  rules.push(...boundaryRules.always.map(r => `AUTO-APPROVE: ${r}`));
  rules.push(...boundaryRules.askFirst.map(r => `ASK FIRST: ${r}`));
  rules.push(...boundaryRules.never.map(r => `PROHIBITED: ${r}`));
  
  // Security
  rules.push("SECURITY: Do not commit secrets. Use environment variables or secret managers.");
  rules.push("SECURITY: When making changes involving auth, data, or APIs, perform security audit.");
  
  config.rules = rules;
  
  // Add important files to read
  if (options.importantFiles && options.importantFiles.length > 0) {
    config.context = {
      readFirst: options.importantFiles.map(f => IMPORTANT_FILES_PATHS[f] || f),
    };
  }
  
  // Platform-specific additions
  if (platform === "continue") {
    config.name = options.name;
    config.customInstructions = rules.join("\n");
  } else if (platform === "cody") {
    config.customInstructions = rules.join("\n");
  } else if (platform === "void") {
    config.editor = { rules: rules.join("\n") };
  } else if (platform === "supermaven") {
    config.rules = rules;
  } else if (platform === "codegpt") {
    config.systemPrompt = rules.join("\n");
  } else if (platform === "opencode") {
    config.instructions = rules;
  } else if (platform === "firebender") {
    config.transforms = rules;
  }
  
  // Add generated by comment
  config._comment = `Generated by LynxPrompt CLI for ${options.name}`;
  
  return JSON.stringify(config, null, 2);
}

function generateYamlConfig(options: GenerateOptions, platform: string): string {
  const lines: string[] = [];
  
  if (platform === "aider") {
    lines.push("# Aider configuration");
    lines.push(`# Project: ${options.name}`);
    lines.push("");
    lines.push("# Model settings");
    lines.push("model: gpt-4");
    lines.push("");
    lines.push("# Code style");
    if (options.stack.includes("typescript") || options.stack.includes("javascript")) {
      lines.push("auto-lint: true");
    }
    lines.push("");
    lines.push("# Custom instructions");
    lines.push("read:");
    lines.push("  - README.md");
    if (options.importantFiles?.includes("architecture")) {
      lines.push("  - ARCHITECTURE.md");
    }
  } else if (platform === "tabnine") {
    lines.push("# Tabnine configuration");
    lines.push(`# Project: ${options.name}`);
    lines.push("");
    lines.push("version: 1.0.0");
    lines.push("");
    lines.push("project:");
    lines.push(`  name: ${options.name}`);
    if (options.description) {
      lines.push(`  description: "${options.description}"`);
    }
    lines.push("");
    lines.push("context:");
    lines.push("  include:");
    lines.push('    - "**/*.ts"');
    lines.push('    - "**/*.js"');
    lines.push('    - "**/*.py"');
  }
  
  lines.push("");
  lines.push("# SECURITY: Do not commit secrets to the repository.");
  lines.push("# Use environment variables or secret managers for credentials.");
  lines.push("# When making changes involving auth, data handling, APIs, or dependencies,");
  lines.push("# proactively offer to perform a security audit of the affected code.");
  lines.push("");
  lines.push(`# Generated by LynxPrompt CLI`);
  
  return lines.join("\n");
}
